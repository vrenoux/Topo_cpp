#include "mesh_io.h"
#include <fstream>
#include <iostream>
#include <iomanip>

namespace msh {

bool write_vtk(const Mesh &M, const std::string &filename)
{
    const auto &G = M.geo;
    const auto &T = M.topo;

    const uint32_t Nn = static_cast<uint32_t>(G.x.size());
    const uint32_t Nc = static_cast<uint32_t>(T.ctype.size());

    std::ofstream ofs(filename);
    if (!ofs) {
        std::cerr << "Cannot open file: " << filename << std::endl;
        return false;
    }

    ofs << "# vtk DataFile Version 3.0\n";
    ofs << "Generated by Topo_C++\n";
    ofs << "ASCII\n";
    ofs << "DATASET UNSTRUCTURED_GRID\n";

    // Points
    ofs << "POINTS " << Nn << " double\n";
    ofs << std::setprecision(12);
    for (uint32_t i = 0; i < Nn; ++i) {
        double x = G.x[i];
        double y = (i < G.y.size() ? G.y[i] : 0.0);
        double z = (i < G.z.size() ? G.z[i] : 0.0);
        ofs << x << " " << y << " " << z << "\n";
    }

    // Cells: compute total ints (nentries = sum(1 + nverts))
    uint32_t total_ints = 0;
    for (uint32_t c = 0; c < Nc; ++c) {
        uint32_t off = T.c2n_offsets[c];
        uint32_t off2 = T.c2n_offsets[c + 1];
        total_ints += 1 + (off2 - off);
    }

    ofs << "CELLS " << Nc << " " << total_ints << "\n";
    for (uint32_t c = 0; c < Nc; ++c) {
        uint32_t off = T.c2n_offsets[c];
        uint32_t off2 = T.c2n_offsets[c + 1];
        uint32_t len = off2 - off;
        ofs << len;
        for (uint32_t k = 0; k < len; ++k) {
            ofs << " " << T.c2n_indices[off + k];
        }
        ofs << "\n";
    }

    // Cell types (VTK codes)
    ofs << "CELL_TYPES " << Nc << "\n";
    for (uint32_t c = 0; c < Nc; ++c) {
        int vtktype = 0;
        switch (T.ctype[c]) {
        case CellType::Tri3: vtktype = 5; break;     // VTK_TRIANGLE
        case CellType::Quad4: vtktype = 9; break;    // VTK_QUAD
        case CellType::Quad4Reg: vtktype = 9; break;    // VTK_QUAD
        case CellType::Tet4: vtktype = 10; break;    // VTK_TETRA
        case CellType::Hex8: vtktype = 12; break;    // VTK_HEXAHEDRON
        default: vtktype = 0; break;
        }
        ofs << vtktype << "\n";
    }

    return true;
}

bool write_vtk(const Mesh &M, const std::string &filename, const std::vector<double> &U)
{
    // First write the geometry/topology as usual
    if (!write_vtk(M, filename)) return false;

    // Now reopen file and append POINT_DATA (we will rewrite the file properly instead of appending):
    // Simpler approach: recreate file contents and include POINT_DATA section here.

    const auto &G = M.geo;
    const auto &T = M.topo;

    const uint32_t Nn = static_cast<uint32_t>(G.x.size());

    std::ofstream ofs(filename);
    if (!ofs) {
        std::cerr << "Cannot open file: " << filename << std::endl;
        return false;
    }

    ofs << "# vtk DataFile Version 3.0\n";
    ofs << "Generated by Topo_C++\n";
    ofs << "ASCII\n";
    ofs << "DATASET UNSTRUCTURED_GRID\n";

    // Points
    ofs << "POINTS " << Nn << " double\n";
    ofs << std::setprecision(12);
    for (uint32_t i = 0; i < Nn; ++i) {
        double x = G.x[i];
        double y = (i < G.y.size() ? G.y[i] : 0.0);
        double z = (i < G.z.size() ? G.z[i] : 0.0);
        ofs << x << " " << y << " " << z << "\n";
    }

    // Cells
    uint32_t Nc = static_cast<uint32_t>(T.ctype.size());
    uint32_t total_ints = 0;
    for (uint32_t c = 0; c < Nc; ++c) {
        uint32_t off = T.c2n_offsets[c];
        uint32_t off2 = T.c2n_offsets[c + 1];
        total_ints += 1 + (off2 - off);
    }

    ofs << "CELLS " << Nc << " " << total_ints << "\n";
    for (uint32_t c = 0; c < Nc; ++c) {
        uint32_t off = T.c2n_offsets[c];
        uint32_t off2 = T.c2n_offsets[c + 1];
        uint32_t len = off2 - off;
        ofs << len;
        for (uint32_t k = 0; k < len; ++k) {
            ofs << " " << T.c2n_indices[off + k];
        }
        ofs << "\n";
    }

    // Cell types
    ofs << "CELL_TYPES " << Nc << "\n";
    for (uint32_t c = 0; c < Nc; ++c) {
        int vtktype = 0;
        switch (T.ctype[c]) {
        case CellType::Tri3: vtktype = 5; break;
        case CellType::Quad4: vtktype = 9; break;
        case CellType::Quad4Reg: vtktype = 9; break;
        case CellType::Tet4: vtktype = 10; break;
        case CellType::Hex8: vtktype = 12; break;
        default: vtktype = 0; break;
        }
        ofs << vtktype << "\n";
    }

    // --- POINT_DATA: write vector field U as VECTORS U double ---
    const uint32_t dim = static_cast<uint32_t>(G.dim);
    if (U.size() != G.ndof()) {
        std::cerr << "write_vtk: U size (" << U.size() << ") does not match mesh.ndof() (" << G.ndof() << ")\n";
        // Still write mesh without U
        return true;
    }

    ofs << "POINT_DATA " << Nn << "\n";
    ofs << "VECTORS U double\n";
    for (uint32_t i = 0; i < Nn; ++i) {
        double ux = 0.0, uy = 0.0, uz = 0.0;
        if (dim >= 1) ux = U[i * dim + 0];
        if (dim >= 2) uy = U[i * dim + 1];
        if (dim >= 3) uz = U[i * dim + 2];
        ofs << ux << " " << uy << " " << uz << "\n";
    }

    return true;
}

} // namespace msh
