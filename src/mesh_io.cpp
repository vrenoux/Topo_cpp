#include "mesh_io.h"
#include <fstream>
#include <iostream>
#include <iomanip>

namespace msh {

bool write_vtk(const Mesh &M, const std::string &filename, const std::vector<VtkField>& fields)
{
    const auto &G = M.geo;
    const auto &T = M.topo;

    std::ofstream ofs(filename);
    if (!ofs) {
        std::cerr << "Cannot open file: " << filename << std::endl;
        return false;
    }

    // --- 1. HEADER & GEOMETRY ---
    ofs << "# vtk DataFile Version 3.0\n";
    ofs << "Generated by Topo_C++\n";
    ofs << "ASCII\n";
    ofs << "DATASET UNSTRUCTURED_GRID\n";

    // Points
    uint32_t Nn = static_cast<uint32_t>(G.x.size());
    ofs << "POINTS " << Nn << " double\n";
    ofs << std::setprecision(6); // Suffisant pour visu, gagne de la place

    for (uint32_t i = 0; i < Nn; ++i) {
        double x = G.x[i];
        double y = (i < G.y.size() ? G.y[i] : 0.0);
        double z = (i < G.z.size() ? G.z[i] : 0.0);
        ofs << x << " " << y << " " << z << "\n";
    }

    // Cells
    uint32_t Nc = static_cast<uint32_t>(T.ctype.size());
    uint32_t total_ints = 0;
    for (uint32_t c = 0; c < Nc; ++c) {
        uint32_t off = T.c2n_offsets[c];
        uint32_t off2 = T.c2n_offsets[c + 1];
        total_ints += 1 + (off2 - off);
    }

    ofs << "CELLS " << Nc << " " << total_ints << "\n";
    for (uint32_t c = 0; c < Nc; ++c) {
        uint32_t off = T.c2n_offsets[c];
        uint32_t off2 = T.c2n_offsets[c + 1];
        uint32_t len = off2 - off;
        ofs << len;
        for (uint32_t k = 0; k < len; ++k) {
            ofs << " " << T.c2n_indices[off + k];
        }
        ofs << "\n";
    }

    // Cell types
    ofs << "CELL_TYPES " << Nc << "\n";
    for (uint32_t c = 0; c < Nc; ++c) {
        int vtktype = 0;
        switch (T.ctype[c]) {
            case CellType::Tri3: vtktype = 5; break;
            case CellType::Quad4: 
            case CellType::Quad4Reg: vtktype = 9; break;
            case CellType::Tet4: vtktype = 10; break;
            case CellType::Hex8: vtktype = 12; break;
            default: vtktype = 0; break;
        }
        ofs << vtktype << "\n";
    }

    // --- 2. POINT_DATA (Champs aux noeuds) ---
    // On doit compter combien de champs sont aux noeuds pour écrire l'header POINT_DATA une seule fois
    bool header_written = false;
    for(const auto& f : fields) {
        if(f.location == FieldLocation::Node) {
            if(!header_written) {
                ofs << "\nPOINT_DATA " << Nn << "\n";
                header_written = true;
            }

            if(f.type == FieldType::Scalar) {
                ofs << "SCALARS " << f.name << " double 1\n";
                ofs << "LOOKUP_TABLE default\n";
                for(double val : f.data) ofs << val << "\n";
            }
            else if(f.type == FieldType::Vector) {
                ofs << "VECTORS " << f.name << " double\n";
                int dim = G.dim;
                // On suppose que data est entrelacé [x0 y0 x1 y1...]
                for(uint32_t i=0; i<Nn; ++i) {
                    double vx = f.data[i*dim + 0];
                    double vy = (dim >= 2) ? f.data[i*dim + 1] : 0.0;
                    double vz = (dim == 3) ? f.data[i*dim + 2] : 0.0;
                    ofs << vx << " " << vy << " " << vz << "\n";
                }
            }
        }
    }

    // --- 3. CELL_DATA (Champs aux cellules) ---
    header_written = false;
    for(const auto& f : fields) {
        if(f.location == FieldLocation::Cell) {
            if(!header_written) {
                ofs << "\nCELL_DATA " << Nc << "\n";
                header_written = true;
            }

            if(f.type == FieldType::Scalar) {
                ofs << "SCALARS " << f.name << " double 1\n";
                ofs << "LOOKUP_TABLE default\n";
                for(double val : f.data) ofs << val << "\n";
            }
            // On peut ajouter Vector Cell Data ici si besoin
        }
    }

    return true;
}

} // namespace msh